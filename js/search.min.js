/**
 * @name Search node Angular library
 * @version v1.2.7
 * @link https://github.com/search-node/searchpt
 */

/**
 * @file
 * Defines the Angular JS application.
 */

// Define the angular applications.
angular.module('searchBoxApp', ['communicationService', 'searchAppConfig', 'angular-cache']);
angular.module('searchResultApp', ['communicationService', 'searchAppConfig', 'ngSanitize']);

/**
 * When the document is ready bootstrap the two applications.
 */
angular.element(document).ready(function ready() {
  "use strict";

  // Bootstrap the search result area. This has to be booted first to ensure
  // that it's ready for events from the search box bootstrap process.
  var result = document.getElementById("searchResultApp");
  if (result) {
    angular.bootstrap(result, ['searchResultApp']);
  }
  else {
    console.error('Unable to bootstrap searchResultApp. Missing HTML tag with id "searchResultApp"');
  }

  // Bootstrap search box.
  var box = document.getElementById("searchBoxApp");
  if (box) {
    angular.bootstrap(box, ['searchBoxApp']);
  }
  else {
    console.error('Unable to bootstrap searchBoxApp. Missing HTML tag with id "searchBoxApp"');
  }
});

/**
 * @file
 * This is the main controller for the application.
 *
 * It controls the search box and filters.
 */

angular.module('searchBoxApp').controller('boxController', ['CONFIG', 'communicatorService', 'searchProxyService', '$scope', '$location', '$rootScope', '$window',
  function (CONFIG, communicatorService, searchProxyService, $scope, $location, $rootScope, $window) {
    'use strict';

    /**
     * Listen to location change event to handle (back/forward button).
     */
    $rootScope.$on('$locationChangeSuccess', function(newLocation, oldLocation) {
      $rootScope.actualHash = $location.hash();
    });

    /**
     *
     */
    $rootScope.$watch(function () {
      return $location.hash();
    }, function (newHash, oldHash) {
      if($rootScope.actualHash === newHash) {
        // @TODO: Figure out why promises stop working when the back/forward
        // buttons in the browser have been user. This is a HACK and hence the
        // code below is dead until we find a solution to promises.
        $window.location.reload();

        //// Get state from previous search.
        //var state = searchProxyService.getState();
        //
        //// Get filters.
        //$scope.filters = state.filters;
        //
        //// Set template to use.
        //$scope.template = CONFIG.templates.box;
        //
        //// Init the query object.
        //$scope.query = {
        //  'text': '',
        //  'filters': {}
        //};
        //
        //// Check if any intervals have been configured.
        //if (CONFIG.provider.hasOwnProperty('intervals')) {
        //  $scope.intervals = CONFIG.provider.intervals;
        //  $scope.query.intervals = {};
        //}
        //
        //// Check if any dates have been configured.
        //if (CONFIG.provider.hasOwnProperty('dates')) {
        //  $scope.dates = CONFIG.provider.dates;
        //  $scope.query.dates = {};
        //}
        //
        //// Check if any search query have been located from the hash tag.
        //if (state.hasOwnProperty('query')) {
        //  // Query found in state, so execute that search.
        //  $scope.query = state.query;
        //}
        //
        //search();
      }
    });

    /**
     * Execute the search and emit the results.
     */
    function search() {
      // Clear auto-complete.
      $scope.autocompleteString = '';

      // Send info to results that a new search have started.
      communicatorService.$emit('searching', {});

      // Add sorting to the search query. It's added here to make it possible to
      // override or add sorting in search queries from the UI. If it was added
      // in the provider it would limit further sorting from the UI.
      if (CONFIG.provider.hasOwnProperty('sorting')) {
        $scope.query.sort = {};
        $scope.query.sort[CONFIG.provider.sorting.field] = CONFIG.provider.sorting.order;
      }

      // Start the search request.
      searchProxyService.search($scope.query).then(
        function (data) {
          // Updated filters.
          searchProxyService.getFilters().then(
            function (filters) {
              $scope.filters = filters;
            },
            function (reason) {
              console.error(reason);
            }
          );

          // Send results.
          communicatorService.$emit('hits', {"hits": data});
        },
        function (reason) {
          console.error(reason);
        }
      );
    }

    /**
     * Initialize the controller and configure the basic scope.
     */
    function init() {
      // Get state from previous search.
      var state = searchProxyService.getState();

      // Get filters.
      $scope.filters = state.filters;

      // Set template to use.
      $scope.template = CONFIG.templates.box;

      // Init the query object.
      $scope.query = {
        'text': '',
        'filters': {}
      };

      // Check if any intervals have been configured.
      if (CONFIG.provider.hasOwnProperty('intervals')) {
        $scope.intervals = CONFIG.provider.intervals;
        $scope.query.intervals = {};
      }

      // Check if any dates have been configured.
      if (CONFIG.provider.hasOwnProperty('dates')) {
        $scope.dates = CONFIG.provider.dates;
        $scope.query.dates = {};
      }

      // Check if any search query have been located from the hash tag.
      if (state.hasOwnProperty('query')) {
        // Query found in state, so execute that search.
        $scope.query = state.query;
        search();
      }
      else {
        // Check if the provider supports an pager.
        if (CONFIG.provider.hasOwnProperty('pager')) {
          // Add pager information to the search query.
          $scope.query.pager = angular.copy(CONFIG.provider.pager);
        }

        // Check if an initial search should be executed.
        if (CONFIG.hasOwnProperty('initialQueryText')) {
          $scope.query.text = angular.copy(CONFIG.initialQueryText);

          // Execute the search.
          search();
        }
        else {
          // Get filters based on search content (maybe slow).
          searchProxyService.getFilters().then(
            function (filters) {
              $scope.filters = filters;
            },
            function (reason) {
              console.error(reason);
            }
          );
        }
      }
    }

    /**
     * Updated search based on pager.
     */
    function pagerUpdated(data) {
      $scope.query.pager = {
        'size': data.size,
        'page': data.page
      };
      search();
    }

    /**
     * Communication listener for pager changes from the search results
     * application.
     */
    communicatorService.$on('pager', function (event, data) {
      var phase = this.$root.$$phase;
      if (phase === '$apply' || phase === '$digest') {
        pagerUpdated(data);
      }
      else {
        $scope.$apply(function () {
          pagerUpdated(data);
        });
      }
    });

    /**
     * Search click handler.
     *
     * Simple wrapper for search that resets the pager before executing the
     * search.
     */
    $scope.searchClicked = function searchClicked() {
      // Reset pager.
      if ($scope.query.hasOwnProperty('pager')) {
        $scope.query.pager = angular.copy(CONFIG.provider.pager);
      }

      search();
    };

    /**
     * Auto-complete callback.
     */
    $scope.autocomplete = function autocomplete() {
      if (CONFIG.provider.hasOwnProperty('autocomplete')) {
        $scope.autocompleteString = '';
        if ($scope.query.text.length >= CONFIG.provider.autocomplete.minChars) {
          searchProxyService.autocomplete($scope.query.text).then(
            function (data) {
              if (data.hits) {
                // Use regex to ensure cases (letters) are matched.
                var re = new RegExp('^' + $scope.query.text, 'i');
                var res = data.results[0][CONFIG.provider.autocomplete.field];
                $scope.autocompleteString = res.replace(re, $scope.query.text);
              }
              else {
                $scope.autocompleteString = '';
              }
            },
            function (reason) {
              console.error(reason);
            }
          );
        }
      }
    };

    // Get the show on the road.
    init();
  }
]);

/**
 * @file
 * This is the controller for the search result application.
 *
 * It simply updates the view when hits have been received.
 */

angular.module('searchResultApp').controller('resultController', ['CONFIG', 'communicatorService', '$scope',
  function (CONFIG, communicatorService, $scope) {
    'use strict';

    // Set template to use.
    $scope.template = CONFIG.templates.result;

    // Scope variable that can be used to make indications on the current
    // process. E.g display spinner.
    $scope.searching = false;

    // Check if the provider supports an pager.
    if (CONFIG.provider.hasOwnProperty('pager')) {
      // Add pager information to the scope.
      $scope.pager = angular.copy(CONFIG.provider.pager);
    }

    /**
     * Update pager information.
     */
    $scope.search = function search() {
      communicatorService.$emit('pager', $scope.pager);
    };

    /**
     * Hanled search results hits from the search box application.
     */
    $scope.hits = [];
    communicatorService.$on('hits', function onHits(event, data) {
      var phase = this.$root.$$phase;
      if (phase === '$apply' || phase === '$digest') {
        $scope.hits = data.hits;
        $scope.searching = false;
      }
      else {
        $scope.$apply(function () {
          $scope.hits = data.hits;
          $scope.searching = false;
        });
      }
    });

    /**
     * Hanled searching message, send when search is called.
     */
    communicatorService.$on('searching', function onSearching(event, data) {
      var phase = this.$root.$$phase;
      if (phase === '$apply' || phase === '$digest') {
        $scope.searching = true;
      }
      else {
        $scope.$apply(function () {
          $scope.searching = true;
        });
      }
    });

    /**
     * Handled pager updates.
     */
    communicatorService.$on('pager', function onPager(event, data) {
      var phase = this.$root.$$phase;
      if (phase === '$apply' || phase === '$digest') {
        $scope.pager = data;
      }
      else {
        $scope.$apply(function () {
          $scope.pager = data;
        });
      }
    });
  }
]);

/**
 * @file
 * Directive to capture key codes.
 *
 * @see http://codepen.io/TheLarkInn/blog/angularjs-directive-labs-ngenterkey.
 *
 * Use by adding html attributes:
 *   data-code="key_code_to_capture"
 *   data-key-code="function_to_call()"
 */
angular.module('searchBoxApp').directive('keyCode', function keyCode() {
  'use strict';

  return {
    restrict: 'A',
    link: function($scope, $element, $attrs) {
      $element.bind("keypress", function(event) {
        var keyCode = event.which || event.keyCode;
        if (keyCode === Number($attrs.code)) {
          $scope.$apply(function() {
            $scope.$eval($attrs.keyCode, { $event: event });
          });
        }
      });
    }
  };
});

/**
 * @file
 * Paging directive.
 */

/**
 * Paging directive.
 *
 * @TODO: Review - maybe use the newer version from https://github.com/aroskanalen/admin/tree/development/web/app/shared/elements/pager
 */
angular.module('searchResultApp').directive('searchPager', ['CONFIG',
  function (CONFIG) {
    'use strict';

    return {
      restrict: 'E',
      replace: true,
      scope: true,
      controller: ["$scope", function ($scope) {

        /**
         * Click handler to change page.
         *
         * @param page
         */
        $scope.changePage = function changePage(page) {
          $scope.pager.page = page;
          $scope.search();
        };

        $scope.prevPage = function prevPage() {
          if ($scope.pager.page > 0) {
            $scope.pager.page--;
            $scope.search();
          }
        };

        $scope.nextPage = function nextPage() {
          if ($scope.pager.page < $scope.pager.max - 1) {
            $scope.pager.page++;
            $scope.search();
          }
        };

        // Keep a watch on changes in number of hits.
        $scope.$watch('hits', function (hits) {
          var pages = [];
          $scope.pager.max = 0;
          if (hits.hits > $scope.pager.size) {
            $scope.pager.max = Math.ceil(hits.hits / $scope.pager.size);
            for (var i = 0; i < $scope.pager.max; i++) {
              pages.push(i);
            }
          }
          $scope.pager.pages = pages;
        });
      }],
      templateUrl: CONFIG.templates.pager
    };
  }
]);

/**
 * @file
 * Dummy search provider that reads the search results from a JSON file.
 */

/**
 * Search provider for JSON files.
 */
angular.module('searchBoxApp').service('jsonProvider', ['CONFIG', '$q', '$http',
  function (CONFIG, $q, $http) {
    'use strict';

    // Load JSON file based on configuration.
    var data = [];
    $http.get(CONFIG.provider.data)
      .then(function(res){
        data = res.data;
      });

    /**
     * The filters available.
     *
     * @returns json array.
     */
    this.getFilters = function getFilters() {
      return {
        'tags': {
          'name': 'Tags',
          'type': 'and',
          'items': [
            {
              'name': 'Angular',
              'value': 'angular'
            },
            {
              'name': 'Developer',
              'value': 'developer'
            },
            {
              'name': 'Javascript',
              'value': 'javascript'
            },
            {
              'name': 'Chrome',
              'value': 'chrome'
            }
          ]
        },
        'levels':{
          'name': 'Levels (or)',
          'type': 'or',
          'items': [
            {
              'name': 'First',
              'value': 1
            },
            {
              'name': 'Second',
              'value': 2
            },
            {
              'name': 'Third',
              'value': 3
            },
            {
              'name': 'Fourth',
              'value': 4
            }
          ]
        }
      };
    };

    /**
     * Search function to query the json data.
     *
     * @param query
     *   The query parameters to search
     *
     * @returns {Array}
     *   The hits found.
     */
    this.search = function search(query) {
      var self = this;
      var hits = angular.copy(data);

      var deferred = $q.defer();

      // Search title.
      if (query.text !== '') {
        hits = JSON.search(data, '//*[contains(title, "' + query.text + '")]');
      }

      // Search filters.
      angular.forEach(query.filters, function (filter, name) {
        // Get search type 'or' or 'and'.
        var type = self.getFilters();
        var xp = false;

        angular.forEach(filter, function (enabled, value) {
          if (enabled) {
            if (type === 'or') {
              // Or type search needs to build and xpath expression for all items
              // in the filter.
              if (xp === false) {
                xp = '//*[' + name + '="' + value + '"]';
              }
              else {
                xp += '|//*[' + name + '="' + value + '"]';
              }
            }
            else {
              // "And" type search simply limites the results.
              hits = JSON.search(hits, '//*[' + name + '="' + value + '"]');
            }
          }
        });

        // After all other search apply the "or" search expression.
        if (type === 'or' && xp) {
          hits = JSON.search(hits, xp);
        }
      });

      // This may seem strange, but it's to keep up with the way search node
      // works. So it makes sense to return and resolve the promise just after
      // each other.
      deferred.resolve({
        'hits': hits.length,
        'results': hits
      });

      return deferred.promise;
    };
  }
]);

/**
 * @file
 * Search provider for the search node framework.
 */

angular.module('searchBoxApp').service('searchNodeProvider', ['CONFIG', '$q', '$http', 'CacheFactory',
  function (CONFIG, $q, $http, CacheFactory) {
    'use strict';

    // Configuration options.
    var configuration = CONFIG.provider;

    // Search node connection handling.
    var socket;
    var loadedSocketIo = false;
    var token = null;

    // Create cache object.
    if (!CacheFactory.get('searchCache')) {
      CacheFactory.createCache('searchCache' + CONFIG.id, {
        maxAge: configuration.cacheExpire * 1000,
        deleteOnExpire: 'aggressive',
        storageMode: 'localStorage'
      });
    }
    var searchCache = CacheFactory.get('searchCache' + CONFIG.id);

    // Holder for the latest search query filters.
    var currentFilters = {
      'taxonomy': undefined,
      'boolean': undefined
    };

    /**
     * Find the size of given object.
     *
     * @return int
     *   The size of the object or 0 if empty.
     */
    function countProperties(obj) {
      var size = 0;
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          size++;
        }
      }

      return size;
    }

    /**
     * Load the socket.io library provided by the search node.
     *
     * @return {promise}
     *   An promise is return that will be resolved on library loaded.
     */
    function loadSocketIoScript() {
      var deferred = $q.defer();

      // Check if it have been loaded.
      if (!loadedSocketIo) {
        // Create script element.
        var script = document.createElement("script");
        script.type = "text/javascript";

        // Add event handlers for the library loaded.
        if (script.readyState) {
          // Handle Internet Explore.
          script.onreadystatechange = function () {
            if (script.readyState === "loaded" || script.readyState === "complete") {
              script.onreadystatechange = null;
              loadedSocketIo = true;
              deferred.resolve();
            }
          };
        } else {
          // All other browsers.
          script.onload = function () {
            loadedSocketIo = true;
            deferred.resolve();
          };
        }

        // Add the script and add it to the dom to load it.
        script.src = configuration.host + "/socket.io/socket.io.js";
        document.getElementsByTagName("head")[0].appendChild(script);
      }
      else {
        deferred.resolve();
      }

      return deferred.promise;
    }

    /**
     * Connect to the web-socket.
     *
     * @param deferred
     *   The deferred object that should be resolved on connection.
     */
    function getSocket(deferred) {
      // Load the socket library.
      loadSocketIoScript().then(function () {
        // Get connected to the server.
        socket = io.connect(configuration.host, {
          'query': 'token=' + token,
          'force new connection': true,
          'max reconnection attempts': Infinity
        });

        // Handle error events.
        socket.on('error', function (reason) {
          console.error(reason, 'Search socket error.');
          deferred.reject(reason);
        });

        socket.on('connect', function () {
          deferred.resolve('Connected to the server.');
        });

        // Handle disconnect event (fires when disconnected or connection fails).
        socket.on('disconnect', function (reason) {
          // @todo: re-connection is automatically handled by socket.io library,
          // but we might need to stop sending request until reconnection or the
          // request will be queued and sent all at once... which could give
          // some strange side effects in the application if not handled.
        });
      });
    }

    /**
     * Create the connection to the server.
     *
     * @return {promise}
     *   A promise is return that will be resolved on connection.
     */
    function connect() {
      // Try to connect to the server if not already connected.
      var deferred = $q.defer();

      if (socket === undefined) {
        if (token !== null) {
          getSocket(deferred);
        }
        else {
          $http.get(configuration.auth)
            .success(function (data) {
              token = data.token;
              getSocket(deferred);
            })
            .error(function (data, status) {
              console.error(data, 'Authentication (search) to search node failed (' + status + ')');
              deferred.reject(status);
            });
        }
      }
      else {
        deferred.resolve('Connected to the server.');
      }

      return deferred.promise;
    }

    /**
     * Builds aggregation query based on filters.
     *
     * @param filters
     */
    function buildAggregationQuery(filters) {
      // Basic aggregation query.
      var query = {
        "aggs": {}
      };

      for (var filterType in filters) {
        switch (filterType) {
          case 'taxonomy':
            var taxonomyFilters = filters[filterType];
            // Extend query with filter fields.
            for (var i = 0; i < taxonomyFilters.length; i++) {
              var filter = taxonomyFilters[i];
              query.aggs[filter.field] = {
                "terms": {
                  "field": filter.field + '.raw',
                  "size": 0
                }
              };
            }
            break;

          case 'boolean':
            var booleanFilters = filters[filterType];
            for (var i = 0; i < booleanFilters.length; i++) {
              var filter = booleanFilters[i];
              query.aggs[filter.field] = {
                "terms": {
                  "field": filter.field,
                  "size": 0
                }
              };
            }
            break;

          default:
            console.error('Aggregation filter has unknown type - ' + filterType);
        }
      }

      return query;
    }

    /**
     * Parse filter configuration and search aggregations.
     *
     * Merge result with filters configuration as not all terms may have
     * been used in the content and then not in found in the search
     * node.
     *
     * @param aggs
     *
     * @returns {{}}
     */
    function parseFilters(aggs) {
      var results = {
        'taxonomy': {},
        'boolean': {}
      };

      if (CONFIG.provider.hasOwnProperty('filters')) {
        var filterConfig = CONFIG.provider.filters;

        for (var filterType in filterConfig) {
          var filters = filterConfig[filterType];
          for (var i = 0; i < filters.length; i++) {
            var filter = angular.copy(filters[i]);

            // Set basic filter with counts.
            results[filterType][filter.field] = {
              'name': filter.name,
            };

            if (countProperties(aggs) !== 0) {
              // Run through counts and update the filters.
              switch (filterType) {
                case 'taxonomy':
                  results[filterType][filter.field].items = filter.terms;

                  for (var j = 0; j < aggs[filter.field].buckets.length; j++) {
                    var bucket = aggs[filter.field].buckets[j];
                    if (results[filterType][filter.field].items.hasOwnProperty(bucket.key)) {
                      results[filterType][filter.field].items[bucket.key].count = Number(bucket.doc_count);
                    }
                    else {
                      console.error('Filter value don\'t match configuration: ' + filter.field + ' -> ' + bucket.key);
                    }
                  }
                  break;

                case 'boolean':
                  for (var j = 0; j < aggs[filter.field].buckets.length; j++) {
                    var bucket = aggs[filter.field].buckets[j];

                    // Set default count for "true" to zero.
                    results[filterType][filter.field].count = 0;
                    if (bucket.key === 'T' && bucket.doc_count > 0) {
                      results[filterType][filter.field].count = Number(bucket.doc_count);

                      // Break has true count have been found, if not we don't break. The
                      // count will be reset to zero.
                      break;
                    }
                  }
                  break;

                default:
                  console.error('Unknown filter type used in parseFilters: ' + filterType);
              }
            }
          }
        }
      }

      return results;
    }

    /**
     * Build boolean filter based on configuration.
     *
     * @returns object
     *   The boolean filter names indexed by field name.
     */
    function buildBooleanFilters() {
      var result = {};

      if (CONFIG.provider.hasOwnProperty('filters')) {
        var filters = CONFIG.provider.filters;

        // Check for boolean filters.
        if (filters.hasOwnProperty('boolean')) {
          for (var i = 0; i < filters.boolean.length; i++) {
            var filter = filters.boolean[i];
            result[filter.field] = {
              'name': filter.name,
            };
          }
        }
      }

      return result;
    }

    /**
     * Get the list of available filters not parsed with search results.
     *
     * @return object
     *  The filters from the configuration.
     */
    this.getRawFilters = function getRawFilters() {
      var result = {};

      if (CONFIG.provider.hasOwnProperty('filters')) {
        var filters = CONFIG.provider.filters;

        // Check for taxonomy filters.
        if (filters.hasOwnProperty('taxonomy')) {
          result.taxonomy = {};
          for (var i = 0; i < filters.taxonomy.length; i++) {
            var filter = filters.taxonomy[i];
            // Set basic filter with counts.
            result.taxonomy[filter.field] = {
              'name': filter.name,
              'items': filter.terms
            };
          }
        }

        // Check for boolean filters.
        result.boolean = buildBooleanFilters();
      }

      return result;
    };

    /**
     * Get the list of available filters.
     *
     * @PLAN:
     *   Check if latest search returned aggregations, if not use the
     *   configuration to search the get all available aggregations.
     *
     *   Merge it with configuration to ensure that all possible filters are
     *   displayed with count.
     */
    this.getFilters = function getFilters() {
      var deferred = $q.defer();

      // Get filters from configuration.
      if (CONFIG.provider.hasOwnProperty('filters')) {
        // If no search has been executed yet, load the default filters across
        // all indexed data.
        if (currentFilters.taxonomy === undefined) {
          // Check if filters are cached.
          var cachedFilters = searchCache.get('filters');

          if (cachedFilters !== undefined) {
            // Store current filters.
            currentFilters = cachedFilters;

            // Return the result.
            deferred.resolve(angular.copy(currentFilters));
          }
          else {
            // Get the query.
            var query = buildAggregationQuery(CONFIG.provider.filters);

            /**
             * @TODO: Added forced fields and other search options.
             */

            // Send the request to search node.
            connect().then(function () {
              socket.emit('count', query);
              socket.once('counts', function (counts) {
                currentFilters = parseFilters(counts);

                // Store initial filters in cache.
                searchCache.put('filters', currentFilters);

                // Return the result.
                deferred.resolve(currentFilters);
              });

              // Catch search errors.
              socket.once('searchError', function (error) {
                console.error('Search error', error.message);
                deferred.reject(error.message);
              });
            });
          }
        }
        else {
          // Return the result.
          deferred.resolve(angular.copy(currentFilters));
        }
      }
      else {
        deferred.resolve({});
      }

      return deferred.promise;
    };

    /**
     * Execute search query.
     *
     * @param searchQuery
     * @returns {*}
     */
    this.search = function search(searchQuery) {
      // Build default "match all" search query.
      var query = {
        "index": configuration.index,
        "query": {
          "filtered": {
            "query": {
              "match_all": {}
            }
          }
        }
      };

      // Text given build field search query.
      // The analyser ensures that we match the who text string sent not part
      // of.
      if (searchQuery.text !== undefined && searchQuery.text !== '') {
        var fields = configuration.fields;
        // Check if boost exist for the fields.
        if (configuration.hasOwnProperty('boost') && countProperties(configuration.boost)) {
          // Add boost to fields.
          for (var i in fields) {
            if (configuration.boost.hasOwnProperty(fields[i])) {
              fields[i] = fields[i] + '^' + configuration.boost[fields[i]];
            }
          }
        }

        query.query.filtered.query = {
          "multi_match": {
            "query": searchQuery.text,
            "type": configuration.hasOwnProperty('match_type') ? configuration.match_type : 'best:fields',
            "fields": fields,
            "analyzer": 'string_search'
          }
        };
      }

      // Add sort fields.
      if (searchQuery.hasOwnProperty('sort') && countProperties(searchQuery.sort) > 0) {
        query.sort = {};
        for (var field in searchQuery.sort) {
          query.sort[field] = {
            "order": searchQuery.sort[field]
          };
        }
      }

      // Add filter.
      if (searchQuery.hasOwnProperty('filters')) {
        var filters = angular.copy(searchQuery.filters);

        // Build query filter.
        var queryFilter = {
          "bool": {
            "must": []
          }
        };

        // Loop over taxonomy filters.
        if (filters.hasOwnProperty('taxonomy')) {
          for (var field in filters.taxonomy) {
            var filter = filters.taxonomy[field];
            /**
             * @TODO: Needs to get information from configuration about execution
             *        type?
             */
            var terms = {
              "execution": "and"
            };

            terms[field + '.raw'] = [];
            for (var term in filter) {
              // Check the the term is "true", hence is selected.
              if (filter[term]) {
                terms[field + '.raw'].push(term);
              }
            }

            if (terms[field + '.raw'].length) {
              queryFilter.bool.must.push({ "terms": terms });
            }
          }
        }

        // Loop over boolean filters.
        if (filters.hasOwnProperty('boolean')) {
          for (var field in filters.boolean) {
            if (filters.boolean[field]) {
              var term = {};
              term[field] = filters.boolean[field];
              queryFilter.bool.must.push({ "term": term });
            }
          }
        }

        // Add the query filter if filled out.
        if (queryFilter.bool.must.length) {
          query.query.filtered.filter = queryFilter;
        }
      }

      // Add pager to the query.
      if (searchQuery.hasOwnProperty('pager')) {
        query.size = searchQuery.pager.size;
        query.from = searchQuery.pager.page * searchQuery.pager.size;
      }

      // Check if aggregations/filters counts should be used.
      if (CONFIG.provider.hasOwnProperty('filters')) {
        // Get the query.
        var aggs = buildAggregationQuery(CONFIG.provider.filters);
        angular.extend(query, aggs);
      }

      // Add range/interval search to the query.
      if (searchQuery.hasOwnProperty('intervals')) {
        // Check if any filters have been defined.
        if (!query.query.filtered.hasOwnProperty('filter')) {
          query.query.filtered.filter = {
            "bool": {
              "must": []
            }
          };
        }

        // Loop over the intervals and build range terms.
        for (var field in searchQuery.intervals) {
          var interval = {
            "range": {}
          };
          interval.range[field] = {
            "gte": searchQuery.intervals[field].from,
            "lte": searchQuery.intervals[field].to
          };
          query.query.filtered.filter.bool.must.push(interval);
        }
      }

      // Add date interval search.
      if (searchQuery.hasOwnProperty('dates')) {
        // Check if any filters have been defined.
        if (!query.query.filtered.hasOwnProperty('filter')) {
          query.query.filtered.filter = {
            "bool": {
              "should": [ ]
            }
          };
        }
        else {
          query.query.filtered.filter.bool.should = [];
        }

        // Loop over the intervals and build range terms.
        for (var field in searchQuery.dates) {
          var config = configuration.dates[field];
          var template = {
            "bool": {
              "must": [
                {
                  "range": {}
                },
                {
                  "range": {}
                }
              ]
            }
          };

          // Overlap start of the interval.
          template.bool.must[0].range[config.from] = {
            "lte": searchQuery.dates[field].from
          };
          template.bool.must[1].range[config.to] = {
            "gt": searchQuery.dates[field].from
          };
          query.query.filtered.filter.bool.should.push(angular.copy(template));

          // Overlap end of the interval.
          template.bool.must[0].range[config.from] = {
            "lt": searchQuery.dates[field].to
          };
          template.bool.must[1].range[config.to] = {
            "gte": searchQuery.dates[field].to
          };
          query.query.filtered.filter.bool.should.push(angular.copy(template));

          // Overlap both endes of the interval.
          template.bool.must[0].range[config.from] = {
            "gte": searchQuery.dates[field].from
          };
          template.bool.must[1].range[config.to] = {
            "lte": searchQuery.dates[field].to
          };
          query.query.filtered.filter.bool.should.push(angular.copy(template));
        }
      }

      // Create cache key based on the finale search query.
      var cid = CryptoJS.MD5(JSON.stringify(query)).toString();

      // Give unique id to the search query.
      query.uuid = cid;

      // Check cache for hits.
      var hits = searchCache.get(cid);

      // Create promise for the search query.
      var deferred = $q.defer();

      if (hits !== undefined) {
        // Update filters cache.
        if (hits.hasOwnProperty('aggs')) {
          currentFilters = parseFilters(angular.copy(hits.aggs));
        }
        deferred.resolve(hits);
      }
      else {
        connect().then(function () {

          /**
           * Search error handler for this event.
           */
          var searchError = function searchError(err) {
            console.error('Search error', err.message);
            deferred.reject(err.message);
          };

          // Listen to search results.
          socket.on('result', function (hits) {
            // Check if this socket message is for this query.
            if (hits.uuid === query.uuid) {
              socket.removeListener('result', this);
              socket.removeListener('searchError', searchError);

              // Update cache filters cache, based on the current search result.
              if (hits.hasOwnProperty('aggs')) {
                // Store current filters.
                currentFilters = parseFilters(angular.copy(hits.aggs));
              }

              // Get uuid and remove it before cache.
              var uuid = hits.uuid;
              delete hits.uuid;

              // Save hits in cache (use uuid as it's it the cache id).
              searchCache.put(uuid, hits);

              deferred.resolve(hits);
            }
          });

          // Catch search errors.
          socket.on('searchError', searchError);

          // Send query.
          socket.emit('search', query);
        });
      }

      return deferred.promise;
    };

    /**
     * Auto-complete search.
     *
     * @param str
     *   The string the search should search for.
     *
     * @returns {promise.promise|Function|jQuery.promise|d.promise|*|promise}
     */
    this.autocomplete = function autocomplete(str) {
      var deferred = $q.defer();

      if (!configuration.hasOwnProperty("autocomplete")) {
        var err = new Error('Auto complete not configured');
        console.error('Search error', err.message);
        deferred.reject(err.message);
      }
      else {
        var query = {
          "index": configuration.autocomplete.index,
          "query": {
            "match_phrase_prefix": {
              "title": {
                "query": str
              }
            }
          },
          "size": configuration.autocomplete.size
        };

        // Add uuid to this search query.
        query.uuid = CryptoJS.MD5(JSON.stringify(query)).toString();

        var hits = searchCache.get(query.uuid);
        if (hits !== undefined) {
          deferred.resolve(hits);
        }
        else {
          // Connect to search node and execute the search.
          connect().then(function () {
            /**
             * Search error handler for this event.
             */
            var searchError = function searchError(err) {
              console.error('Search error', err.message);
              deferred.reject(err.message);
            };

            // Listen to search results.
            socket.on('result', function (hits) {
              // Check if this socket message is for this query.
              if (hits.uuid === query.uuid) {
                socket.removeListener('result', this);
                socket.removeListener('searchError', searchError);

                // Get uuid and remove it before cache.
                var uuid = hits.uuid;
                delete hits.uuid;

                // Save hit in cache.
                searchCache.put(uuid, hits);

                deferred.resolve(hits);
              }
            });

            // Catch search errors.
            socket.on('searchError', searchError);

            // Send query.
            socket.emit('search', query);
          });
        }
      }

      return deferred.promise;
    };

    /**
     * Send query directly to search node.
     *
     * Sends the raw query given in the parameter to search node and
     * elasticearch.
     *
     *  Basically elasticsearch query as the on below extended with the index
     *  to use.
     *
     *  {
     *    "index": 'bd6f534b05ab6073e04afef2c67e7e44',
     *    "query": {
     *       "match_phrase_prefix": {
     *         "title": {
     *           "query": 'test string'
     *         }
     *       }
     *     },
     *    "size": 10
     *  }
     *
     * @param query
     *   JSON search query.
     *
     * @returns {*|promise.promise|Function|jQuery.promise|d.promise|promise}
     */
    this.rawQuerySearch = function rawQuerySearch(query) {
      var deferred = $q.defer();

      // Add uuid to this search query.
      query.uuid = CryptoJS.MD5(JSON.stringify(query)).toString();

      var hits = searchCache.get(query.uuid);
      if (hits !== undefined) {
        deferred.resolve(hits);
      }
      else {
        // Connect to search node and execute the search.
        connect().then(function () {
          /**
           * Search error handler for this event.
           */
          var searchError = function searchError(err) {
            console.error('Search error', err.message);
            deferred.reject(err.message);
          };

          // Listen to search results.
          socket.on('result', function (hits) {
            // Check if this socket message is for this query.
            if (hits.uuid === query.uuid) {
              socket.removeListener('result', this);
              socket.removeListener('searchError', searchError);

              // Get uuid and remove it before cache.
              var uuid = hits.uuid;
              delete hits.uuid;

              // Save hit in cache.
              searchCache.put(uuid, hits);

              deferred.resolve(hits);
            }
          });

          // Catch search errors.
          socket.on('searchError', searchError);

          // Send query.
          socket.emit('search', query);
        });
      }

      return deferred.promise;
    };

  }
]);

/**
 * @file
 * Service to communication between search box and search result applications.
 */

angular.module('communicationService', [])
  .service('communicatorService', ["$rootScope", "$window", function($rootScope, $window){
    'use strict';

    // Store rootScopes for each service user.
    $window.rootScopes = $window.rootScopes || [];
    $window.rootScopes.push($rootScope);

    /**
     * Wrapper for emitting events to all root scopes.
     *
     * @param name
     *   Event name
     * @param args
     *   Event arguments.
     */
    this.$emit = function emit(name, args) {
      angular.forEach($window.rootScopes, function(scope) {
        scope.$emit(name, args);
      });
    };

    /**
     * Wrapper to attach event listeners to the current root scope.
     *
     * @param name
     *   Event name.
     * @param listener
     *   The listener to call on event.
     */
    this.$on = function on(name, listener) {
      $rootScope.$on(name, function (event, message) {
        listener.apply($rootScope, [event, message]);
      });
    };
  }]);
/**
 * @file
 * Search proxy.
 *
 * Allows the framework to use different search back-ends based on
 * configuration settings.
 */

/**
 * Search proxy is used to send search requests to the configured provider.
 */

angular.module('searchBoxApp').service('searchProxyService', ['CONFIG', 'communicatorService', '$injector', '$location',
  function (CONFIG, communicatorService, $injector, $location) {
    'use strict';

    // Load provider based on configuration.
    var provider = $injector.get(CONFIG.provider.service);

    /**
     * Find the size of given object.
     *
     * @return int
     *   The size of the object or 0 if empty.
     */
    function countProperties(obj) {
      var size = 0;
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          size++;
        }
      }

      return size;
    }

    /**
     * Encode the query object into a string.
     *
     * @param query
     *   The query object.
     *
     * @return string
     *   The encoded string that can been used as hash tag in url.
     */
    function encodeSearchQuery(query) {
      var parts = [];

      // Search text.
      if (query.hasOwnProperty('text') && query.text.length !== 0) {
        parts.push('text=' + encodeURIComponent(query.text));
      }

      // Filters.
      if (query.hasOwnProperty('filters')) {
        for (var type in query.filters) {
          if (countProperties(query.filters[type]) !== 0) {
            var filter = query.filters[type];
            var filterParts = [];
            for (var field in filter) {
              var selected = [];

              // Check if it's a simple boolean filter.
              if (typeof filter[field] === "boolean" && filter[field] === true) {
                filterParts.push(field);
              }
              else {
                // Multi level filters (taxonomy).
                for (var i in filter[field]) {
                  if (filter[field][i] === true) {
                    selected.push(i);
                  }
                }

                // Only add the filter if filter have selections.
                if (selected.length) {
                  filterParts.push(field + ':' + selected.join(';'));
                }
              }
            }

            // Only encode filters if any have be selected.
            if (filterParts.length) {
              parts.push('filters[' + type + ']=' + encodeURIComponent(filterParts.join('?')));
            }
          }
        }
      }

      // Interval search.
      if (query.hasOwnProperty('intervals') && countProperties(query.intervals) !== 0) {
        var intervalParts = [];
        for (var field in query.intervals) {
          var interval = query.intervals[field];
          intervalParts.push(field + ';' + interval.from + ';' + interval.to);
        }
        parts.push('intervals=' + encodeURIComponent(intervalParts.join('?')));
      }

      // Date search.
      if (query.hasOwnProperty('dates') && countProperties(query.dates) !== 0) {
        // @TODO: This is the same as for intervals. Refactor into function or
        // loop over type.
        var dateParts = [];
        for (var field in query.dates) {
            var date = query.dates[field];
          dateParts.push(field + ';' + date.from + ';' + date.to);
        }
        parts.push('dates=' + encodeURIComponent(dateParts.join('?')));
      }

      // Pager page.
      if (query.hasOwnProperty('pager')) {
        parts.push('pager=' + query.pager.page + ':' + query.pager.size);
      }

      return parts.join('&');
    }

    /**
     * Decode the hash tag string into search query object.
     *
     * @param string
     *   The encode string that can be used as hash tag in url.
     *
     * @return object
     *   Search query object.
     */
    function decodeSearchQuery(string) {
      var query = {};

      // Get parts.
      var parts = string.split('&');
      for (var part in parts) {
        // Decode the type identifier.
        var subParts = parts[part].split('=');
        var type = decodeURIComponent(subParts[0]);
        if (type.indexOf('[') !== -1) {
          type = type.substr(0, type.indexOf('['));
        }

        switch (type) {
          case 'text':
            query.text = decodeURIComponent(subParts[1]);
            break;

          case 'filters':
            var str = decodeURIComponent(subParts[0]);
            var filterType = str.substr(str.indexOf('[') + 1).slice(0, -1);
            var filters = decodeURIComponent(subParts[1]).split('?');

            if (filters.length) {
              // Initialize the filters on the query object.
              if (!query.hasOwnProperty('filters')) {
                query.filters = {
                  'taxonomy': {},
                  'boolean': {}
                };
              }

              for (var i in filters) {
                switch (filterType) {
                  case 'taxonomy':
                    var filter = filters[i].split(':');
                    // Reduce the array values into an object.
                    query.filters[filterType][filter[0]] = filter[1].split(';').reduce(function (obj, val, index) {
                      obj[val] = true;
                      return obj;
                    }, {});
                    break;

                  case 'boolean':
                    query.filters[filterType][filters[i]] = true;
                    break;

                  default:
                    console.error('Decoding of search hash has unknown filter type - ' + filterType);
                }

              }
            }
            break;

          case 'intervals':
            var intervals = decodeURIComponent(subParts[1]).split('?');
            if (intervals.length) {
              query.intervals = {};
              for (var i in intervals) {
                var interval = intervals[i].split(';');
                query.intervals[interval[0]] = {
                  'from': interval[1],
                  'to': interval[2]
                };
              }
            }
            break;

          // @TODO: This is the same as for intervals. Refactor into function.
          case 'dates':
            var dates = decodeURIComponent(subParts[1]).split('?');
            if (dates.length) {
              query.dates = {};
              for (var i in dates) {
                var date = dates[i].split(';');
                query.dates[date[0]] = {
                  'from': date[1],
                  'to': date[2]
                };
              }
            }
            break;

          case 'pager':
            var pager = subParts[1].split(':');
            query.pager = {
              'page': Number(pager[0]),
              'size': Number(pager[1])
            };
            break;

          default:
            console.error('Decoding of search hash has unknown parts - ' + subParts[0]);
        }
      }

      return query;
    }

    /**
     * Get basic information about the search state.
     *
     * @return object
     *  The last query form hash tag and default filters.
     */
    this.getState = function getState() {
      var state = {
        'filters': this.getRawFilters()
      };

      var hash = $location.hash();
      if (hash.length > 2) {
         state.query = decodeSearchQuery(hash);
      }

      return state;
    };

    /**
     * Search the provider loaded.
     *
     * This simply forwards the search request to the provider loaded.
     *
     * @param searchQuery
     *   The search query.
     * @param byPassUrlEncode
     *   Don't encode the query in the browsers URL. Default false.
     *
     * @returns {Number|*|Object}
     *   The search result.
     */
    this.search = function search(searchQuery, byPassUrlEncode) {
      byPassUrlEncode = (typeof byPassUrlEncode === 'undefined') ? false : byPassUrlEncode;

      // Ensure that forced fields and other changes are not reflected in the
      // UI.
      var query = angular.copy(searchQuery);

      // Ensure that intervals are set in the configuration and have both from
      // and to values.
      if (CONFIG.provider.hasOwnProperty('intervals') && CONFIG.provider.intervals.length) {
        if (query.hasOwnProperty('intervals')) {
          for (var field in query.intervals) {
            // Check if both from and to exists.
            // @TODO: Review - This can be flipped to avoid the "empty" if - continue does nothing :)
            if (!(query.intervals[field].hasOwnProperty('from') && query.intervals[field].from !== '') &&
                !(query.intervals[field].hasOwnProperty('to') && query.intervals[field].to !== '')) {
              // Remove invalidated interval.
              delete query.intervals[field];
            }
          }
        }
      }
      else {
        // Configuration does not have intervals.
        if (query.hasOwnProperty('intervals')) {
          delete query.intervals;
        }
      }

      // Keep track of the current URL.
      if (!byPassUrlEncode) {
        $location.path('/');
        $location.hash(encodeSearchQuery(query));
      }

      // Force search filters form configuration (predefined filters).
      if (CONFIG.provider.hasOwnProperty('force') && CONFIG.provider.force.length) {
        // If the query has been loaded form the URL, it may not have any
        // selected filters, hence no filters on the query object.
        if (!query.hasOwnProperty('filters')) {
          query.filters = {};
        }

        var forces = CONFIG.provider.force;
        for (var i in forces) {
          var force = forces[i];

          // Check filter type.
          if (!query.filters.hasOwnProperty(force.type)) {
            query.filters[force.type] = {};
          }

          // Check if user have selected filter, if not init it.
          if (!query.filters.hasOwnProperty(force.field)) {
            query.filters[force.type][force.field] = {};
          }

          // Insert the forced field values.
          for (var j in force.values) {
            query.filters[force.type][force.field][force.values[j]] = true;
          }
        }
      }

      return provider.search(query);
    };

    /**
     * Send auto-complete request.
     *
     * Search on from the beginning of a field.
     *
     * @param str
     *   The partial string to search for.
     *
     * @returns json
     */
    this.autocomplete = function autocomplete(str) {
      return provider.autocomplete(str);
    };

    /**
     * Send raw search query request.
     *
     * @param query
     *   The search query.
     *
     * @returns json
     */
    this.rawQuerySearch = function rawQuerySearch(query) {
      return provider.rawQuerySearch(query);
    };

    /**
     * Get filters provided by configuration.
     *
     * @returns json
     */
    this.getRawFilters = function getRawFilters() {
      return provider.getRawFilters();
    };

    /**
     * Get filters provided by search engine used.
     *
     * @returns json
     */
    this.getFilters = function getFilters() {
      return provider.getFilters();
    };
  }
]);

//# sourceMappingURL=maps/search.js.map
