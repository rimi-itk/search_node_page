/**
 * @name Search node Angular library
 * @version v1.2.7
 * @link https://github.com/search-node/searchpt
 */
{"version":3,"sources":["search.js","controllers/boxController.js","controllers/resultController.js","directive/keyCodeDirective.js","directive/pagerDirective.js","providers/jsonProvider.js","providers/searchNodeProvider.js","services/communicationService.js","services/searchProxyService.js"],"names":[],"mappings":"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","file":"search.js","sourcesContent":["\n/**\n * @file\n * Defines the Angular JS application.\n */\n\n// Define the angular applications.\nangular.module('searchBoxApp', ['communicationService', 'searchAppConfig', 'angular-cache']);\nangular.module('searchResultApp', ['communicationService', 'searchAppConfig', 'ngSanitize']);\n\n/**\n * When the document is ready bootstrap the two applications.\n */\nangular.element(document).ready(function ready() {\n  \"use strict\";\n\n  // Bootstrap the search result area. This has to be booted first to ensure\n  // that it's ready for events from the search box bootstrap process.\n  var result = document.getElementById(\"searchResultApp\");\n  if (result) {\n    angular.bootstrap(result, ['searchResultApp']);\n  }\n  else {\n    console.error('Unable to bootstrap searchResultApp. Missing HTML tag with id \"searchResultApp\"');\n  }\n\n  // Bootstrap search box.\n  var box = document.getElementById(\"searchBoxApp\");\n  if (box) {\n    angular.bootstrap(box, ['searchBoxApp']);\n  }\n  else {\n    console.error('Unable to bootstrap searchBoxApp. Missing HTML tag with id \"searchBoxApp\"');\n  }\n});\n","/**\n * @file\n * This is the main controller for the application.\n *\n * It controls the search box and filters.\n */\n\nangular.module('searchBoxApp').controller('boxController', ['CONFIG', 'communicatorService', 'searchProxyService', '$scope', '$location', '$rootScope', '$window',\n  function (CONFIG, communicatorService, searchProxyService, $scope, $location, $rootScope, $window) {\n    'use strict';\n\n    /**\n     * Listen to location change event to handle (back/forward button).\n     */\n    $rootScope.$on('$locationChangeSuccess', function(newLocation, oldLocation) {\n      $rootScope.actualHash = $location.hash();\n    });\n\n    /**\n     *\n     */\n    $rootScope.$watch(function () {\n      return $location.hash();\n    }, function (newHash, oldHash) {\n      if($rootScope.actualHash === newHash) {\n        // @TODO: Figure out why promises stop working when the back/forward\n        // buttons in the browser have been user. This is a HACK and hence the\n        // code below is dead until we find a solution to promises.\n        $window.location.reload();\n\n        //// Get state from previous search.\n        //var state = searchProxyService.getState();\n        //\n        //// Get filters.\n        //$scope.filters = state.filters;\n        //\n        //// Set template to use.\n        //$scope.template = CONFIG.templates.box;\n        //\n        //// Init the query object.\n        //$scope.query = {\n        //  'text': '',\n        //  'filters': {}\n        //};\n        //\n        //// Check if any intervals have been configured.\n        //if (CONFIG.provider.hasOwnProperty('intervals')) {\n        //  $scope.intervals = CONFIG.provider.intervals;\n        //  $scope.query.intervals = {};\n        //}\n        //\n        //// Check if any dates have been configured.\n        //if (CONFIG.provider.hasOwnProperty('dates')) {\n        //  $scope.dates = CONFIG.provider.dates;\n        //  $scope.query.dates = {};\n        //}\n        //\n        //// Check if any search query have been located from the hash tag.\n        //if (state.hasOwnProperty('query')) {\n        //  // Query found in state, so execute that search.\n        //  $scope.query = state.query;\n        //}\n        //\n        //search();\n      }\n    });\n\n    /**\n     * Execute the search and emit the results.\n     */\n    function search() {\n      // Clear auto-complete.\n      $scope.autocompleteString = '';\n\n      // Send info to results that a new search have started.\n      communicatorService.$emit('searching', {});\n\n      // Add sorting to the search query. It's added here to make it possible to\n      // override or add sorting in search queries from the UI. If it was added\n      // in the provider it would limit further sorting from the UI.\n      if (CONFIG.provider.hasOwnProperty('sorting')) {\n        $scope.query.sort = {};\n        $scope.query.sort[CONFIG.provider.sorting.field] = CONFIG.provider.sorting.order;\n      }\n\n      // Start the search request.\n      searchProxyService.search($scope.query).then(\n        function (data) {\n          // Updated filters.\n          searchProxyService.getFilters().then(\n            function (filters) {\n              $scope.filters = filters;\n            },\n            function (reason) {\n              console.error(reason);\n            }\n          );\n\n          // Send results.\n          communicatorService.$emit('hits', {\"hits\": data});\n        },\n        function (reason) {\n          console.error(reason);\n        }\n      );\n    }\n\n    /**\n     * Initialize the controller and configure the basic scope.\n     */\n    function init() {\n      // Get state from previous search.\n      var state = searchProxyService.getState();\n\n      // Get filters.\n      $scope.filters = state.filters;\n\n      // Set template to use.\n      $scope.template = CONFIG.templates.box;\n\n      // Init the query object.\n      $scope.query = {\n        'text': '',\n        'filters': {}\n      };\n\n      // Check if any intervals have been configured.\n      if (CONFIG.provider.hasOwnProperty('intervals')) {\n        $scope.intervals = CONFIG.provider.intervals;\n        $scope.query.intervals = {};\n      }\n\n      // Check if any dates have been configured.\n      if (CONFIG.provider.hasOwnProperty('dates')) {\n        $scope.dates = CONFIG.provider.dates;\n        $scope.query.dates = {};\n      }\n\n      // Check if any search query have been located from the hash tag.\n      if (state.hasOwnProperty('query')) {\n        // Query found in state, so execute that search.\n        $scope.query = state.query;\n        search();\n      }\n      else {\n        // Check if the provider supports an pager.\n        if (CONFIG.provider.hasOwnProperty('pager')) {\n          // Add pager information to the search query.\n          $scope.query.pager = angular.copy(CONFIG.provider.pager);\n        }\n\n        // Check if an initial search should be executed.\n        if (CONFIG.hasOwnProperty('initialQueryText')) {\n          $scope.query.text = angular.copy(CONFIG.initialQueryText);\n\n          // Execute the search.\n          search();\n        }\n        else {\n          // Get filters based on search content (maybe slow).\n          searchProxyService.getFilters().then(\n            function (filters) {\n              $scope.filters = filters;\n            },\n            function (reason) {\n              console.error(reason);\n            }\n          );\n        }\n      }\n    }\n\n    /**\n     * Updated search based on pager.\n     */\n    function pagerUpdated(data) {\n      $scope.query.pager = {\n        'size': data.size,\n        'page': data.page\n      };\n      search();\n    }\n\n    /**\n     * Communication listener for pager changes from the search results\n     * application.\n     */\n    communicatorService.$on('pager', function (event, data) {\n      var phase = this.$root.$$phase;\n      if (phase === '$apply' || phase === '$digest') {\n        pagerUpdated(data);\n      }\n      else {\n        $scope.$apply(function () {\n          pagerUpdated(data);\n        });\n      }\n    });\n\n    /**\n     * Search click handler.\n     *\n     * Simple wrapper for search that resets the pager before executing the\n     * search.\n     */\n    $scope.searchClicked = function searchClicked() {\n      // Reset pager.\n      if ($scope.query.hasOwnProperty('pager')) {\n        $scope.query.pager = angular.copy(CONFIG.provider.pager);\n      }\n\n      search();\n    };\n\n    /**\n     * Auto-complete callback.\n     */\n    $scope.autocomplete = function autocomplete() {\n      if (CONFIG.provider.hasOwnProperty('autocomplete')) {\n        $scope.autocompleteString = '';\n        if ($scope.query.text.length >= CONFIG.provider.autocomplete.minChars) {\n          searchProxyService.autocomplete($scope.query.text).then(\n            function (data) {\n              if (data.hits) {\n                // Use regex to ensure cases (letters) are matched.\n                var re = new RegExp('^' + $scope.query.text, 'i');\n                var res = data.results[0][CONFIG.provider.autocomplete.field];\n                $scope.autocompleteString = res.replace(re, $scope.query.text);\n              }\n              else {\n                $scope.autocompleteString = '';\n              }\n            },\n            function (reason) {\n              console.error(reason);\n            }\n          );\n        }\n      }\n    };\n\n    // Get the show on the road.\n    init();\n  }\n]);\n","/**\n * @file\n * This is the controller for the search result application.\n *\n * It simply updates the view when hits have been received.\n */\n\nangular.module('searchResultApp').controller('resultController', ['CONFIG', 'communicatorService', '$scope',\n  function (CONFIG, communicatorService, $scope) {\n    'use strict';\n\n    // Set template to use.\n    $scope.template = CONFIG.templates.result;\n\n    // Scope variable that can be used to make indications on the current\n    // process. E.g display spinner.\n    $scope.searching = false;\n\n    // Check if the provider supports an pager.\n    if (CONFIG.provider.hasOwnProperty('pager')) {\n      // Add pager information to the scope.\n      $scope.pager = angular.copy(CONFIG.provider.pager);\n    }\n\n    /**\n     * Update pager information.\n     */\n    $scope.search = function search() {\n      communicatorService.$emit('pager', $scope.pager);\n    };\n\n    /**\n     * Hanled search results hits from the search box application.\n     */\n    $scope.hits = [];\n    communicatorService.$on('hits', function onHits(event, data) {\n      var phase = this.$root.$$phase;\n      if (phase === '$apply' || phase === '$digest') {\n        $scope.hits = data.hits;\n        $scope.searching = false;\n      }\n      else {\n        $scope.$apply(function () {\n          $scope.hits = data.hits;\n          $scope.searching = false;\n        });\n      }\n    });\n\n    /**\n     * Hanled searching message, send when search is called.\n     */\n    communicatorService.$on('searching', function onSearching(event, data) {\n      var phase = this.$root.$$phase;\n      if (phase === '$apply' || phase === '$digest') {\n        $scope.searching = true;\n      }\n      else {\n        $scope.$apply(function () {\n          $scope.searching = true;\n        });\n      }\n    });\n\n    /**\n     * Handled pager updates.\n     */\n    communicatorService.$on('pager', function onPager(event, data) {\n      var phase = this.$root.$$phase;\n      if (phase === '$apply' || phase === '$digest') {\n        $scope.pager = data;\n      }\n      else {\n        $scope.$apply(function () {\n          $scope.pager = data;\n        });\n      }\n    });\n  }\n]);\n","/**\n * @file\n * Directive to capture key codes.\n *\n * @see http://codepen.io/TheLarkInn/blog/angularjs-directive-labs-ngenterkey.\n *\n * Use by adding html attributes:\n *   data-code=\"key_code_to_capture\"\n *   data-key-code=\"function_to_call()\"\n */\nangular.module('searchBoxApp').directive('keyCode', function keyCode() {\n  'use strict';\n\n  return {\n    restrict: 'A',\n    link: function($scope, $element, $attrs) {\n      $element.bind(\"keypress\", function(event) {\n        var keyCode = event.which || event.keyCode;\n        if (keyCode === Number($attrs.code)) {\n          $scope.$apply(function() {\n            $scope.$eval($attrs.keyCode, { $event: event });\n          });\n        }\n      });\n    }\n  };\n});\n","/**\n * @file\n * Paging directive.\n */\n\n/**\n * Paging directive.\n *\n * @TODO: Review - maybe use the newer version from https://github.com/aroskanalen/admin/tree/development/web/app/shared/elements/pager\n */\nangular.module('searchResultApp').directive('searchPager', ['CONFIG',\n  function (CONFIG) {\n    'use strict';\n\n    return {\n      restrict: 'E',\n      replace: true,\n      scope: true,\n      controller: function ($scope) {\n\n        /**\n         * Click handler to change page.\n         *\n         * @param page\n         */\n        $scope.changePage = function changePage(page) {\n          $scope.pager.page = page;\n          $scope.search();\n        };\n\n        $scope.prevPage = function prevPage() {\n          if ($scope.pager.page > 0) {\n            $scope.pager.page--;\n            $scope.search();\n          }\n        };\n\n        $scope.nextPage = function nextPage() {\n          if ($scope.pager.page < $scope.pager.max - 1) {\n            $scope.pager.page++;\n            $scope.search();\n          }\n        };\n\n        // Keep a watch on changes in number of hits.\n        $scope.$watch('hits', function (hits) {\n          var pages = [];\n          $scope.pager.max = 0;\n          if (hits.hits > $scope.pager.size) {\n            $scope.pager.max = Math.ceil(hits.hits / $scope.pager.size);\n            for (var i = 0; i < $scope.pager.max; i++) {\n              pages.push(i);\n            }\n          }\n          $scope.pager.pages = pages;\n        });\n      },\n      templateUrl: CONFIG.templates.pager\n    };\n  }\n]);\n","/**\n * @file\n * Dummy search provider that reads the search results from a JSON file.\n */\n\n/**\n * Search provider for JSON files.\n */\nangular.module('searchBoxApp').service('jsonProvider', ['CONFIG', '$q', '$http',\n  function (CONFIG, $q, $http) {\n    'use strict';\n\n    // Load JSON file based on configuration.\n    var data = [];\n    $http.get(CONFIG.provider.data)\n      .then(function(res){\n        data = res.data;\n      });\n\n    /**\n     * The filters available.\n     *\n     * @returns json array.\n     */\n    this.getFilters = function getFilters() {\n      return {\n        'tags': {\n          'name': 'Tags',\n          'type': 'and',\n          'items': [\n            {\n              'name': 'Angular',\n              'value': 'angular'\n            },\n            {\n              'name': 'Developer',\n              'value': 'developer'\n            },\n            {\n              'name': 'Javascript',\n              'value': 'javascript'\n            },\n            {\n              'name': 'Chrome',\n              'value': 'chrome'\n            }\n          ]\n        },\n        'levels':{\n          'name': 'Levels (or)',\n          'type': 'or',\n          'items': [\n            {\n              'name': 'First',\n              'value': 1\n            },\n            {\n              'name': 'Second',\n              'value': 2\n            },\n            {\n              'name': 'Third',\n              'value': 3\n            },\n            {\n              'name': 'Fourth',\n              'value': 4\n            }\n          ]\n        }\n      };\n    };\n\n    /**\n     * Search function to query the json data.\n     *\n     * @param query\n     *   The query parameters to search\n     *\n     * @returns {Array}\n     *   The hits found.\n     */\n    this.search = function search(query) {\n      var self = this;\n      var hits = angular.copy(data);\n\n      var deferred = $q.defer();\n\n      // Search title.\n      if (query.text !== '') {\n        hits = JSON.search(data, '//*[contains(title, \"' + query.text + '\")]');\n      }\n\n      // Search filters.\n      angular.forEach(query.filters, function (filter, name) {\n        // Get search type 'or' or 'and'.\n        var type = self.getFilters();\n        var xp = false;\n\n        angular.forEach(filter, function (enabled, value) {\n          if (enabled) {\n            if (type === 'or') {\n              // Or type search needs to build and xpath expression for all items\n              // in the filter.\n              if (xp === false) {\n                xp = '//*[' + name + '=\"' + value + '\"]';\n              }\n              else {\n                xp += '|//*[' + name + '=\"' + value + '\"]';\n              }\n            }\n            else {\n              // \"And\" type search simply limites the results.\n              hits = JSON.search(hits, '//*[' + name + '=\"' + value + '\"]');\n            }\n          }\n        });\n\n        // After all other search apply the \"or\" search expression.\n        if (type === 'or' && xp) {\n          hits = JSON.search(hits, xp);\n        }\n      });\n\n      // This may seem strange, but it's to keep up with the way search node\n      // works. So it makes sense to return and resolve the promise just after\n      // each other.\n      deferred.resolve({\n        'hits': hits.length,\n        'results': hits\n      });\n\n      return deferred.promise;\n    };\n  }\n]);\n","/**\n * @file\n * Search provider for the search node framework.\n */\n\nangular.module('searchBoxApp').service('searchNodeProvider', ['CONFIG', '$q', '$http', 'CacheFactory',\n  function (CONFIG, $q, $http, CacheFactory) {\n    'use strict';\n\n    // Configuration options.\n    var configuration = CONFIG.provider;\n\n    // Search node connection handling.\n    var socket;\n    var loadedSocketIo = false;\n    var token = null;\n\n    // Create cache object.\n    if (!CacheFactory.get('searchCache')) {\n      CacheFactory.createCache('searchCache' + CONFIG.id, {\n        maxAge: configuration.cacheExpire * 1000,\n        deleteOnExpire: 'aggressive',\n        storageMode: 'localStorage'\n      });\n    }\n    var searchCache = CacheFactory.get('searchCache' + CONFIG.id);\n\n    // Holder for the latest search query filters.\n    var currentFilters = {\n      'taxonomy': undefined,\n      'boolean': undefined\n    };\n\n    /**\n     * Find the size of given object.\n     *\n     * @return int\n     *   The size of the object or 0 if empty.\n     */\n    function countProperties(obj) {\n      var size = 0;\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          size++;\n        }\n      }\n\n      return size;\n    }\n\n    /**\n     * Load the socket.io library provided by the search node.\n     *\n     * @return {promise}\n     *   An promise is return that will be resolved on library loaded.\n     */\n    function loadSocketIoScript() {\n      var deferred = $q.defer();\n\n      // Check if it have been loaded.\n      if (!loadedSocketIo) {\n        // Create script element.\n        var script = document.createElement(\"script\");\n        script.type = \"text/javascript\";\n\n        // Add event handlers for the library loaded.\n        if (script.readyState) {\n          // Handle Internet Explore.\n          script.onreadystatechange = function () {\n            if (script.readyState === \"loaded\" || script.readyState === \"complete\") {\n              script.onreadystatechange = null;\n              loadedSocketIo = true;\n              deferred.resolve();\n            }\n          };\n        } else {\n          // All other browsers.\n          script.onload = function () {\n            loadedSocketIo = true;\n            deferred.resolve();\n          };\n        }\n\n        // Add the script and add it to the dom to load it.\n        script.src = configuration.host + \"/socket.io/socket.io.js\";\n        document.getElementsByTagName(\"head\")[0].appendChild(script);\n      }\n      else {\n        deferred.resolve();\n      }\n\n      return deferred.promise;\n    }\n\n    /**\n     * Connect to the web-socket.\n     *\n     * @param deferred\n     *   The deferred object that should be resolved on connection.\n     */\n    function getSocket(deferred) {\n      // Load the socket library.\n      loadSocketIoScript().then(function () {\n        // Get connected to the server.\n        socket = io.connect(configuration.host, {\n          'query': 'token=' + token,\n          'force new connection': true,\n          'max reconnection attempts': Infinity\n        });\n\n        // Handle error events.\n        socket.on('error', function (reason) {\n          console.error(reason, 'Search socket error.');\n          deferred.reject(reason);\n        });\n\n        socket.on('connect', function () {\n          deferred.resolve('Connected to the server.');\n        });\n\n        // Handle disconnect event (fires when disconnected or connection fails).\n        socket.on('disconnect', function (reason) {\n          // @todo: re-connection is automatically handled by socket.io library,\n          // but we might need to stop sending request until reconnection or the\n          // request will be queued and sent all at once... which could give\n          // some strange side effects in the application if not handled.\n        });\n      });\n    }\n\n    /**\n     * Create the connection to the server.\n     *\n     * @return {promise}\n     *   A promise is return that will be resolved on connection.\n     */\n    function connect() {\n      // Try to connect to the server if not already connected.\n      var deferred = $q.defer();\n\n      if (socket === undefined) {\n        if (token !== null) {\n          getSocket(deferred);\n        }\n        else {\n          $http.get(configuration.auth)\n            .success(function (data) {\n              token = data.token;\n              getSocket(deferred);\n            })\n            .error(function (data, status) {\n              console.error(data, 'Authentication (search) to search node failed (' + status + ')');\n              deferred.reject(status);\n            });\n        }\n      }\n      else {\n        deferred.resolve('Connected to the server.');\n      }\n\n      return deferred.promise;\n    }\n\n    /**\n     * Builds aggregation query based on filters.\n     *\n     * @param filters\n     */\n    function buildAggregationQuery(filters) {\n      // Basic aggregation query.\n      var query = {\n        \"aggs\": {}\n      };\n\n      for (var filterType in filters) {\n        switch (filterType) {\n          case 'taxonomy':\n            var taxonomyFilters = filters[filterType];\n            // Extend query with filter fields.\n            for (var i = 0; i < taxonomyFilters.length; i++) {\n              var filter = taxonomyFilters[i];\n              query.aggs[filter.field] = {\n                \"terms\": {\n                  \"field\": filter.field + '.raw',\n                  \"size\": 0\n                }\n              };\n            }\n            break;\n\n          case 'boolean':\n            var booleanFilters = filters[filterType];\n            for (var i = 0; i < booleanFilters.length; i++) {\n              var filter = booleanFilters[i];\n              query.aggs[filter.field] = {\n                \"terms\": {\n                  \"field\": filter.field,\n                  \"size\": 0\n                }\n              };\n            }\n            break;\n\n          default:\n            console.error('Aggregation filter has unknown type - ' + filterType);\n        }\n      }\n\n      return query;\n    }\n\n    /**\n     * Parse filter configuration and search aggregations.\n     *\n     * Merge result with filters configuration as not all terms may have\n     * been used in the content and then not in found in the search\n     * node.\n     *\n     * @param aggs\n     *\n     * @returns {{}}\n     */\n    function parseFilters(aggs) {\n      var results = {\n        'taxonomy': {},\n        'boolean': {}\n      };\n\n      if (CONFIG.provider.hasOwnProperty('filters')) {\n        var filterConfig = CONFIG.provider.filters;\n\n        for (var filterType in filterConfig) {\n          var filters = filterConfig[filterType];\n          for (var i = 0; i < filters.length; i++) {\n            var filter = angular.copy(filters[i]);\n\n            // Set basic filter with counts.\n            results[filterType][filter.field] = {\n              'name': filter.name,\n            };\n\n            if (countProperties(aggs) !== 0) {\n              // Run through counts and update the filters.\n              switch (filterType) {\n                case 'taxonomy':\n                  results[filterType][filter.field].items = filter.terms;\n\n                  for (var j = 0; j < aggs[filter.field].buckets.length; j++) {\n                    var bucket = aggs[filter.field].buckets[j];\n                    if (results[filterType][filter.field].items.hasOwnProperty(bucket.key)) {\n                      results[filterType][filter.field].items[bucket.key].count = Number(bucket.doc_count);\n                    }\n                    else {\n                      console.error('Filter value don\\'t match configuration: ' + filter.field + ' -> ' + bucket.key);\n                    }\n                  }\n                  break;\n\n                case 'boolean':\n                  for (var j = 0; j < aggs[filter.field].buckets.length; j++) {\n                    var bucket = aggs[filter.field].buckets[j];\n\n                    // Set default count for \"true\" to zero.\n                    results[filterType][filter.field].count = 0;\n                    if (bucket.key === 'T' && bucket.doc_count > 0) {\n                      results[filterType][filter.field].count = Number(bucket.doc_count);\n\n                      // Break has true count have been found, if not we don't break. The\n                      // count will be reset to zero.\n                      break;\n                    }\n                  }\n                  break;\n\n                default:\n                  console.error('Unknown filter type used in parseFilters: ' + filterType);\n              }\n            }\n          }\n        }\n      }\n\n      return results;\n    }\n\n    /**\n     * Build boolean filter based on configuration.\n     *\n     * @returns object\n     *   The boolean filter names indexed by field name.\n     */\n    function buildBooleanFilters() {\n      var result = {};\n\n      if (CONFIG.provider.hasOwnProperty('filters')) {\n        var filters = CONFIG.provider.filters;\n\n        // Check for boolean filters.\n        if (filters.hasOwnProperty('boolean')) {\n          for (var i = 0; i < filters.boolean.length; i++) {\n            var filter = filters.boolean[i];\n            result[filter.field] = {\n              'name': filter.name,\n            };\n          }\n        }\n      }\n\n      return result;\n    }\n\n    /**\n     * Get the list of available filters not parsed with search results.\n     *\n     * @return object\n     *  The filters from the configuration.\n     */\n    this.getRawFilters = function getRawFilters() {\n      var result = {};\n\n      if (CONFIG.provider.hasOwnProperty('filters')) {\n        var filters = CONFIG.provider.filters;\n\n        // Check for taxonomy filters.\n        if (filters.hasOwnProperty('taxonomy')) {\n          result.taxonomy = {};\n          for (var i = 0; i < filters.taxonomy.length; i++) {\n            var filter = filters.taxonomy[i];\n            // Set basic filter with counts.\n            result.taxonomy[filter.field] = {\n              'name': filter.name,\n              'items': filter.terms\n            };\n          }\n        }\n\n        // Check for boolean filters.\n        result.boolean = buildBooleanFilters();\n      }\n\n      return result;\n    };\n\n    /**\n     * Get the list of available filters.\n     *\n     * @PLAN:\n     *   Check if latest search returned aggregations, if not use the\n     *   configuration to search the get all available aggregations.\n     *\n     *   Merge it with configuration to ensure that all possible filters are\n     *   displayed with count.\n     */\n    this.getFilters = function getFilters() {\n      var deferred = $q.defer();\n\n      // Get filters from configuration.\n      if (CONFIG.provider.hasOwnProperty('filters')) {\n        // If no search has been executed yet, load the default filters across\n        // all indexed data.\n        if (currentFilters.taxonomy === undefined) {\n          // Check if filters are cached.\n          var cachedFilters = searchCache.get('filters');\n\n          if (cachedFilters !== undefined) {\n            // Store current filters.\n            currentFilters = cachedFilters;\n\n            // Return the result.\n            deferred.resolve(angular.copy(currentFilters));\n          }\n          else {\n            // Get the query.\n            var query = buildAggregationQuery(CONFIG.provider.filters);\n\n            /**\n             * @TODO: Added forced fields and other search options.\n             */\n\n            // Send the request to search node.\n            connect().then(function () {\n              socket.emit('count', query);\n              socket.once('counts', function (counts) {\n                currentFilters = parseFilters(counts);\n\n                // Store initial filters in cache.\n                searchCache.put('filters', currentFilters);\n\n                // Return the result.\n                deferred.resolve(currentFilters);\n              });\n\n              // Catch search errors.\n              socket.once('searchError', function (error) {\n                console.error('Search error', error.message);\n                deferred.reject(error.message);\n              });\n            });\n          }\n        }\n        else {\n          // Return the result.\n          deferred.resolve(angular.copy(currentFilters));\n        }\n      }\n      else {\n        deferred.resolve({});\n      }\n\n      return deferred.promise;\n    };\n\n    /**\n     * Execute search query.\n     *\n     * @param searchQuery\n     * @returns {*}\n     */\n    this.search = function search(searchQuery) {\n      // Build default \"match all\" search query.\n      var query = {\n        \"index\": configuration.index,\n        \"query\": {\n          \"filtered\": {\n            \"query\": {\n              \"match_all\": {}\n            }\n          }\n        }\n      };\n\n      // Text given build field search query.\n      // The analyser ensures that we match the who text string sent not part\n      // of.\n      if (searchQuery.text !== undefined && searchQuery.text !== '') {\n        var fields = configuration.fields;\n        // Check if boost exist for the fields.\n        if (configuration.hasOwnProperty('boost') && countProperties(configuration.boost)) {\n          // Add boost to fields.\n          for (var i in fields) {\n            if (configuration.boost.hasOwnProperty(fields[i])) {\n              fields[i] = fields[i] + '^' + configuration.boost[fields[i]];\n            }\n          }\n        }\n\n        query.query.filtered.query = {\n          \"multi_match\": {\n            \"query\": searchQuery.text,\n            \"type\": configuration.hasOwnProperty('match_type') ? configuration.match_type : 'best:fields',\n            \"fields\": fields,\n            \"analyzer\": 'string_search'\n          }\n        };\n      }\n\n      // Add sort fields.\n      if (searchQuery.hasOwnProperty('sort') && countProperties(searchQuery.sort) > 0) {\n        query.sort = {};\n        for (var field in searchQuery.sort) {\n          query.sort[field] = {\n            \"order\": searchQuery.sort[field]\n          };\n        }\n      }\n\n      // Add filter.\n      if (searchQuery.hasOwnProperty('filters')) {\n        var filters = angular.copy(searchQuery.filters);\n\n        // Build query filter.\n        var queryFilter = {\n          \"bool\": {\n            \"must\": []\n          }\n        };\n\n        // Loop over taxonomy filters.\n        if (filters.hasOwnProperty('taxonomy')) {\n          for (var field in filters.taxonomy) {\n            var filter = filters.taxonomy[field];\n            /**\n             * @TODO: Needs to get information from configuration about execution\n             *        type?\n             */\n            var terms = {\n              \"execution\": \"and\"\n            };\n\n            terms[field + '.raw'] = [];\n            for (var term in filter) {\n              // Check the the term is \"true\", hence is selected.\n              if (filter[term]) {\n                terms[field + '.raw'].push(term);\n              }\n            }\n\n            if (terms[field + '.raw'].length) {\n              queryFilter.bool.must.push({ \"terms\": terms });\n            }\n          }\n        }\n\n        // Loop over boolean filters.\n        if (filters.hasOwnProperty('boolean')) {\n          for (var field in filters.boolean) {\n            if (filters.boolean[field]) {\n              var term = {};\n              term[field] = filters.boolean[field];\n              queryFilter.bool.must.push({ \"term\": term });\n            }\n          }\n        }\n\n        // Add the query filter if filled out.\n        if (queryFilter.bool.must.length) {\n          query.query.filtered.filter = queryFilter;\n        }\n      }\n\n      // Add pager to the query.\n      if (searchQuery.hasOwnProperty('pager')) {\n        query.size = searchQuery.pager.size;\n        query.from = searchQuery.pager.page * searchQuery.pager.size;\n      }\n\n      // Check if aggregations/filters counts should be used.\n      if (CONFIG.provider.hasOwnProperty('filters')) {\n        // Get the query.\n        var aggs = buildAggregationQuery(CONFIG.provider.filters);\n        angular.extend(query, aggs);\n      }\n\n      // Add range/interval search to the query.\n      if (searchQuery.hasOwnProperty('intervals')) {\n        // Check if any filters have been defined.\n        if (!query.query.filtered.hasOwnProperty('filter')) {\n          query.query.filtered.filter = {\n            \"bool\": {\n              \"must\": []\n            }\n          };\n        }\n\n        // Loop over the intervals and build range terms.\n        for (var field in searchQuery.intervals) {\n          var interval = {\n            \"range\": {}\n          };\n          interval.range[field] = {\n            \"gte\": searchQuery.intervals[field].from,\n            \"lte\": searchQuery.intervals[field].to\n          };\n          query.query.filtered.filter.bool.must.push(interval);\n        }\n      }\n\n      // Add date interval search.\n      if (searchQuery.hasOwnProperty('dates')) {\n        // Check if any filters have been defined.\n        if (!query.query.filtered.hasOwnProperty('filter')) {\n          query.query.filtered.filter = {\n            \"bool\": {\n              \"should\": [ ]\n            }\n          };\n        }\n        else {\n          query.query.filtered.filter.bool.should = [];\n        }\n\n        // Loop over the intervals and build range terms.\n        for (var field in searchQuery.dates) {\n          var config = configuration.dates[field];\n          var template = {\n            \"bool\": {\n              \"must\": [\n                {\n                  \"range\": {}\n                },\n                {\n                  \"range\": {}\n                }\n              ]\n            }\n          };\n\n          // Overlap start of the interval.\n          template.bool.must[0].range[config.from] = {\n            \"lte\": searchQuery.dates[field].from\n          };\n          template.bool.must[1].range[config.to] = {\n            \"gt\": searchQuery.dates[field].from\n          };\n          query.query.filtered.filter.bool.should.push(angular.copy(template));\n\n          // Overlap end of the interval.\n          template.bool.must[0].range[config.from] = {\n            \"lt\": searchQuery.dates[field].to\n          };\n          template.bool.must[1].range[config.to] = {\n            \"gte\": searchQuery.dates[field].to\n          };\n          query.query.filtered.filter.bool.should.push(angular.copy(template));\n\n          // Overlap both endes of the interval.\n          template.bool.must[0].range[config.from] = {\n            \"gte\": searchQuery.dates[field].from\n          };\n          template.bool.must[1].range[config.to] = {\n            \"lte\": searchQuery.dates[field].to\n          };\n          query.query.filtered.filter.bool.should.push(angular.copy(template));\n        }\n      }\n\n      // Create cache key based on the finale search query.\n      var cid = CryptoJS.MD5(JSON.stringify(query)).toString();\n\n      // Give unique id to the search query.\n      query.uuid = cid;\n\n      // Check cache for hits.\n      var hits = searchCache.get(cid);\n\n      // Create promise for the search query.\n      var deferred = $q.defer();\n\n      if (hits !== undefined) {\n        // Update filters cache.\n        if (hits.hasOwnProperty('aggs')) {\n          currentFilters = parseFilters(angular.copy(hits.aggs));\n        }\n        deferred.resolve(hits);\n      }\n      else {\n        connect().then(function () {\n\n          /**\n           * Search error handler for this event.\n           */\n          var searchError = function searchError(err) {\n            console.error('Search error', err.message);\n            deferred.reject(err.message);\n          };\n\n          // Listen to search results.\n          socket.on('result', function (hits) {\n            // Check if this socket message is for this query.\n            if (hits.uuid === query.uuid) {\n              socket.removeListener('result', this);\n              socket.removeListener('searchError', searchError);\n\n              // Update cache filters cache, based on the current search result.\n              if (hits.hasOwnProperty('aggs')) {\n                // Store current filters.\n                currentFilters = parseFilters(angular.copy(hits.aggs));\n              }\n\n              // Get uuid and remove it before cache.\n              var uuid = hits.uuid;\n              delete hits.uuid;\n\n              // Save hits in cache (use uuid as it's it the cache id).\n              searchCache.put(uuid, hits);\n\n              deferred.resolve(hits);\n            }\n          });\n\n          // Catch search errors.\n          socket.on('searchError', searchError);\n\n          // Send query.\n          socket.emit('search', query);\n        });\n      }\n\n      return deferred.promise;\n    };\n\n    /**\n     * Auto-complete search.\n     *\n     * @param str\n     *   The string the search should search for.\n     *\n     * @returns {promise.promise|Function|jQuery.promise|d.promise|*|promise}\n     */\n    this.autocomplete = function autocomplete(str) {\n      var deferred = $q.defer();\n\n      if (!configuration.hasOwnProperty(\"autocomplete\")) {\n        var err = new Error('Auto complete not configured');\n        console.error('Search error', err.message);\n        deferred.reject(err.message);\n      }\n      else {\n        var query = {\n          \"index\": configuration.autocomplete.index,\n          \"query\": {\n            \"match_phrase_prefix\": {\n              \"title\": {\n                \"query\": str\n              }\n            }\n          },\n          \"size\": configuration.autocomplete.size\n        };\n\n        // Add uuid to this search query.\n        query.uuid = CryptoJS.MD5(JSON.stringify(query)).toString();\n\n        var hits = searchCache.get(query.uuid);\n        if (hits !== undefined) {\n          deferred.resolve(hits);\n        }\n        else {\n          // Connect to search node and execute the search.\n          connect().then(function () {\n            /**\n             * Search error handler for this event.\n             */\n            var searchError = function searchError(err) {\n              console.error('Search error', err.message);\n              deferred.reject(err.message);\n            };\n\n            // Listen to search results.\n            socket.on('result', function (hits) {\n              // Check if this socket message is for this query.\n              if (hits.uuid === query.uuid) {\n                socket.removeListener('result', this);\n                socket.removeListener('searchError', searchError);\n\n                // Get uuid and remove it before cache.\n                var uuid = hits.uuid;\n                delete hits.uuid;\n\n                // Save hit in cache.\n                searchCache.put(uuid, hits);\n\n                deferred.resolve(hits);\n              }\n            });\n\n            // Catch search errors.\n            socket.on('searchError', searchError);\n\n            // Send query.\n            socket.emit('search', query);\n          });\n        }\n      }\n\n      return deferred.promise;\n    };\n\n    /**\n     * Send query directly to search node.\n     *\n     * Sends the raw query given in the parameter to search node and\n     * elasticearch.\n     *\n     *  Basically elasticsearch query as the on below extended with the index\n     *  to use.\n     *\n     *  {\n     *    \"index\": 'bd6f534b05ab6073e04afef2c67e7e44',\n     *    \"query\": {\n     *       \"match_phrase_prefix\": {\n     *         \"title\": {\n     *           \"query\": 'test string'\n     *         }\n     *       }\n     *     },\n     *    \"size\": 10\n     *  }\n     *\n     * @param query\n     *   JSON search query.\n     *\n     * @returns {*|promise.promise|Function|jQuery.promise|d.promise|promise}\n     */\n    this.rawQuerySearch = function rawQuerySearch(query) {\n      var deferred = $q.defer();\n\n      // Add uuid to this search query.\n      query.uuid = CryptoJS.MD5(JSON.stringify(query)).toString();\n\n      var hits = searchCache.get(query.uuid);\n      if (hits !== undefined) {\n        deferred.resolve(hits);\n      }\n      else {\n        // Connect to search node and execute the search.\n        connect().then(function () {\n          /**\n           * Search error handler for this event.\n           */\n          var searchError = function searchError(err) {\n            console.error('Search error', err.message);\n            deferred.reject(err.message);\n          };\n\n          // Listen to search results.\n          socket.on('result', function (hits) {\n            // Check if this socket message is for this query.\n            if (hits.uuid === query.uuid) {\n              socket.removeListener('result', this);\n              socket.removeListener('searchError', searchError);\n\n              // Get uuid and remove it before cache.\n              var uuid = hits.uuid;\n              delete hits.uuid;\n\n              // Save hit in cache.\n              searchCache.put(uuid, hits);\n\n              deferred.resolve(hits);\n            }\n          });\n\n          // Catch search errors.\n          socket.on('searchError', searchError);\n\n          // Send query.\n          socket.emit('search', query);\n        });\n      }\n\n      return deferred.promise;\n    };\n\n  }\n]);\n","/**\n * @file\n * Service to communication between search box and search result applications.\n */\n\nangular.module('communicationService', [])\n  .service('communicatorService', function($rootScope, $window){\n    'use strict';\n\n    // Store rootScopes for each service user.\n    $window.rootScopes = $window.rootScopes || [];\n    $window.rootScopes.push($rootScope);\n\n    /**\n     * Wrapper for emitting events to all root scopes.\n     *\n     * @param name\n     *   Event name\n     * @param args\n     *   Event arguments.\n     */\n    this.$emit = function emit(name, args) {\n      angular.forEach($window.rootScopes, function(scope) {\n        scope.$emit(name, args);\n      });\n    };\n\n    /**\n     * Wrapper to attach event listeners to the current root scope.\n     *\n     * @param name\n     *   Event name.\n     * @param listener\n     *   The listener to call on event.\n     */\n    this.$on = function on(name, listener) {\n      $rootScope.$on(name, function (event, message) {\n        listener.apply($rootScope, [event, message]);\n      });\n    };\n  });","/**\n * @file\n * Search proxy.\n *\n * Allows the framework to use different search back-ends based on\n * configuration settings.\n */\n\n/**\n * Search proxy is used to send search requests to the configured provider.\n */\n\nangular.module('searchBoxApp').service('searchProxyService', ['CONFIG', 'communicatorService', '$injector', '$location',\n  function (CONFIG, communicatorService, $injector, $location) {\n    'use strict';\n\n    // Load provider based on configuration.\n    var provider = $injector.get(CONFIG.provider.service);\n\n    /**\n     * Find the size of given object.\n     *\n     * @return int\n     *   The size of the object or 0 if empty.\n     */\n    function countProperties(obj) {\n      var size = 0;\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          size++;\n        }\n      }\n\n      return size;\n    }\n\n    /**\n     * Encode the query object into a string.\n     *\n     * @param query\n     *   The query object.\n     *\n     * @return string\n     *   The encoded string that can been used as hash tag in url.\n     */\n    function encodeSearchQuery(query) {\n      var parts = [];\n\n      // Search text.\n      if (query.hasOwnProperty('text') && query.text.length !== 0) {\n        parts.push('text=' + encodeURIComponent(query.text));\n      }\n\n      // Filters.\n      if (query.hasOwnProperty('filters')) {\n        for (var type in query.filters) {\n          if (countProperties(query.filters[type]) !== 0) {\n            var filter = query.filters[type];\n            var filterParts = [];\n            for (var field in filter) {\n              var selected = [];\n\n              // Check if it's a simple boolean filter.\n              if (typeof filter[field] === \"boolean\" && filter[field] === true) {\n                filterParts.push(field);\n              }\n              else {\n                // Multi level filters (taxonomy).\n                for (var i in filter[field]) {\n                  if (filter[field][i] === true) {\n                    selected.push(i);\n                  }\n                }\n\n                // Only add the filter if filter have selections.\n                if (selected.length) {\n                  filterParts.push(field + ':' + selected.join(';'));\n                }\n              }\n            }\n\n            // Only encode filters if any have be selected.\n            if (filterParts.length) {\n              parts.push('filters[' + type + ']=' + encodeURIComponent(filterParts.join('?')));\n            }\n          }\n        }\n      }\n\n      // Interval search.\n      if (query.hasOwnProperty('intervals') && countProperties(query.intervals) !== 0) {\n        var intervalParts = [];\n        for (var field in query.intervals) {\n          var interval = query.intervals[field];\n          intervalParts.push(field + ';' + interval.from + ';' + interval.to);\n        }\n        parts.push('intervals=' + encodeURIComponent(intervalParts.join('?')));\n      }\n\n      // Date search.\n      if (query.hasOwnProperty('dates') && countProperties(query.dates) !== 0) {\n        // @TODO: This is the same as for intervals. Refactor into function or\n        // loop over type.\n        var dateParts = [];\n        for (var field in query.dates) {\n            var date = query.dates[field];\n          dateParts.push(field + ';' + date.from + ';' + date.to);\n        }\n        parts.push('dates=' + encodeURIComponent(dateParts.join('?')));\n      }\n\n      // Pager page.\n      if (query.hasOwnProperty('pager')) {\n        parts.push('pager=' + query.pager.page + ':' + query.pager.size);\n      }\n\n      return parts.join('&');\n    }\n\n    /**\n     * Decode the hash tag string into search query object.\n     *\n     * @param string\n     *   The encode string that can be used as hash tag in url.\n     *\n     * @return object\n     *   Search query object.\n     */\n    function decodeSearchQuery(string) {\n      var query = {};\n\n      // Get parts.\n      var parts = string.split('&');\n      for (var part in parts) {\n        // Decode the type identifier.\n        var subParts = parts[part].split('=');\n        var type = decodeURIComponent(subParts[0]);\n        if (type.indexOf('[') !== -1) {\n          type = type.substr(0, type.indexOf('['));\n        }\n\n        switch (type) {\n          case 'text':\n            query.text = decodeURIComponent(subParts[1]);\n            break;\n\n          case 'filters':\n            var str = decodeURIComponent(subParts[0]);\n            var filterType = str.substr(str.indexOf('[') + 1).slice(0, -1);\n            var filters = decodeURIComponent(subParts[1]).split('?');\n\n            if (filters.length) {\n              // Initialize the filters on the query object.\n              if (!query.hasOwnProperty('filters')) {\n                query.filters = {\n                  'taxonomy': {},\n                  'boolean': {}\n                };\n              }\n\n              for (var i in filters) {\n                switch (filterType) {\n                  case 'taxonomy':\n                    var filter = filters[i].split(':');\n                    // Reduce the array values into an object.\n                    query.filters[filterType][filter[0]] = filter[1].split(';').reduce(function (obj, val, index) {\n                      obj[val] = true;\n                      return obj;\n                    }, {});\n                    break;\n\n                  case 'boolean':\n                    query.filters[filterType][filters[i]] = true;\n                    break;\n\n                  default:\n                    console.error('Decoding of search hash has unknown filter type - ' + filterType);\n                }\n\n              }\n            }\n            break;\n\n          case 'intervals':\n            var intervals = decodeURIComponent(subParts[1]).split('?');\n            if (intervals.length) {\n              query.intervals = {};\n              for (var i in intervals) {\n                var interval = intervals[i].split(';');\n                query.intervals[interval[0]] = {\n                  'from': interval[1],\n                  'to': interval[2]\n                };\n              }\n            }\n            break;\n\n          // @TODO: This is the same as for intervals. Refactor into function.\n          case 'dates':\n            var dates = decodeURIComponent(subParts[1]).split('?');\n            if (dates.length) {\n              query.dates = {};\n              for (var i in dates) {\n                var date = dates[i].split(';');\n                query.dates[date[0]] = {\n                  'from': date[1],\n                  'to': date[2]\n                };\n              }\n            }\n            break;\n\n          case 'pager':\n            var pager = subParts[1].split(':');\n            query.pager = {\n              'page': Number(pager[0]),\n              'size': Number(pager[1])\n            };\n            break;\n\n          default:\n            console.error('Decoding of search hash has unknown parts - ' + subParts[0]);\n        }\n      }\n\n      return query;\n    }\n\n    /**\n     * Get basic information about the search state.\n     *\n     * @return object\n     *  The last query form hash tag and default filters.\n     */\n    this.getState = function getState() {\n      var state = {\n        'filters': this.getRawFilters()\n      };\n\n      var hash = $location.hash();\n      if (hash.length > 2) {\n         state.query = decodeSearchQuery(hash);\n      }\n\n      return state;\n    };\n\n    /**\n     * Search the provider loaded.\n     *\n     * This simply forwards the search request to the provider loaded.\n     *\n     * @param searchQuery\n     *   The search query.\n     * @param byPassUrlEncode\n     *   Don't encode the query in the browsers URL. Default false.\n     *\n     * @returns {Number|*|Object}\n     *   The search result.\n     */\n    this.search = function search(searchQuery, byPassUrlEncode) {\n      byPassUrlEncode = (typeof byPassUrlEncode === 'undefined') ? false : byPassUrlEncode;\n\n      // Ensure that forced fields and other changes are not reflected in the\n      // UI.\n      var query = angular.copy(searchQuery);\n\n      // Ensure that intervals are set in the configuration and have both from\n      // and to values.\n      if (CONFIG.provider.hasOwnProperty('intervals') && CONFIG.provider.intervals.length) {\n        if (query.hasOwnProperty('intervals')) {\n          for (var field in query.intervals) {\n            // Check if both from and to exists.\n            // @TODO: Review - This can be flipped to avoid the \"empty\" if - continue does nothing :)\n            if (!(query.intervals[field].hasOwnProperty('from') && query.intervals[field].from !== '') &&\n                !(query.intervals[field].hasOwnProperty('to') && query.intervals[field].to !== '')) {\n              // Remove invalidated interval.\n              delete query.intervals[field];\n            }\n          }\n        }\n      }\n      else {\n        // Configuration does not have intervals.\n        if (query.hasOwnProperty('intervals')) {\n          delete query.intervals;\n        }\n      }\n\n      // Keep track of the current URL.\n      if (!byPassUrlEncode) {\n        $location.path('/');\n        $location.hash(encodeSearchQuery(query));\n      }\n\n      // Force search filters form configuration (predefined filters).\n      if (CONFIG.provider.hasOwnProperty('force') && CONFIG.provider.force.length) {\n        // If the query has been loaded form the URL, it may not have any\n        // selected filters, hence no filters on the query object.\n        if (!query.hasOwnProperty('filters')) {\n          query.filters = {};\n        }\n\n        var forces = CONFIG.provider.force;\n        for (var i in forces) {\n          var force = forces[i];\n\n          // Check filter type.\n          if (!query.filters.hasOwnProperty(force.type)) {\n            query.filters[force.type] = {};\n          }\n\n          // Check if user have selected filter, if not init it.\n          if (!query.filters.hasOwnProperty(force.field)) {\n            query.filters[force.type][force.field] = {};\n          }\n\n          // Insert the forced field values.\n          for (var j in force.values) {\n            query.filters[force.type][force.field][force.values[j]] = true;\n          }\n        }\n      }\n\n      return provider.search(query);\n    };\n\n    /**\n     * Send auto-complete request.\n     *\n     * Search on from the beginning of a field.\n     *\n     * @param str\n     *   The partial string to search for.\n     *\n     * @returns json\n     */\n    this.autocomplete = function autocomplete(str) {\n      return provider.autocomplete(str);\n    };\n\n    /**\n     * Send raw search query request.\n     *\n     * @param query\n     *   The search query.\n     *\n     * @returns json\n     */\n    this.rawQuerySearch = function rawQuerySearch(query) {\n      return provider.rawQuerySearch(query);\n    };\n\n    /**\n     * Get filters provided by configuration.\n     *\n     * @returns json\n     */\n    this.getRawFilters = function getRawFilters() {\n      return provider.getRawFilters();\n    };\n\n    /**\n     * Get filters provided by search engine used.\n     *\n     * @returns json\n     */\n    this.getFilters = function getFilters() {\n      return provider.getFilters();\n    };\n  }\n]);\n"],"sourceRoot":"/source/"}